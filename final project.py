# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ek-9FWZOH6_eEeKwWV3a0cXZEBVXrdFZ
"""

import matplotlib.pyplot as plt
import pandas as pd
import nltk
nltk.download('punkt')
from nltk.tokenize import word_tokenize

from sklearn.model_selection import train_test_split
from sklearn import linear_model
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
from lightgbm import LGBMRegressor
from xgboost.sklearn import XGBRegressor
from sklearn.kernel_ridge import KernelRidge
from sklearn.ensemble import GradientBoostingRegressor
from sklearn.linear_model import ElasticNet
from sklearn.linear_model import SGDRegressor
from sklearn.svm import SVR
from sklearn.linear_model import BayesianRidge

import seaborn as sns

pd.set_option('display.max_columns', None)


def draw_prices(dataset):
  """Draw a graph with prices"""
  plt.hist(dataset["Selling price"], label="Цена")
  plt.xlabel("Цена")
  plt.ylabel("Количество смартфонов")
  plt.title('Ценовой диапазон')
  plt.legend()
  plt.show()


def draw_average_prices(company, price):
  """Draw a graph with average prices per company"""
  plt.bar(company, price, label='Цена')
  plt.xlabel('Компании')
  plt.ylabel('Средняя цена')
  plt.title('Средняя цена смартфонов')
  plt.legend()
  plt.show()


def resolve_company_names(companies):
  """
    This method finds the names of companies.

    Args:
        names: contains the names of companies

    Returns:
        Sorted list of names
  """
  names = list()
  for mobilePhone in companies:
    names.append(word_tokenize(mobilePhone)[0])
  names = set(names)
  return names


def count_average_price(companies, dataset):
  """
    This method finds the average price per phone for each company.

    Args:
        average_price: contains the average price of smartphones for each manufacturer
        filtered_ds: contains the modified dataset
        price: contains averaged prices

    Returns:
        The average price of a smartphone for each manufacturer
  """
  average_price = list()
  for company in companies:
    filtered_ds = dataset[dataset['Mobile'].str.startswith(company)]
    price = filtered_ds['Selling price'].mean()
    average_price.append(price)
  return average_price

def split_data(dt, tg):
  """
    This method splits the data for test and train with .

    Args:
        dt: data set
        tg: name of target column ( for wich we find regression)

    Returns:
        f_train (feature train set), f_test (feature test set), t_train (target train set), t_test (target test set)
  """

  d = dt.drop("Mobile", axis=1) # we drop this coz this column is name of phone and we dont use it in regression
  f = d.drop(tg, axis=1) # feature data set is set of all data except target column
  td = d[tg] # target data set is set of only target column
  f_train, f_test, t_train, t_test = train_test_split(f, td, test_size=0.25, random_state=42)
  return [f_train, f_test, t_train, t_test]

def fit_and_predict_all(fr1, fe1, tr1, te1, name):
  """
    This method sequenseally execute all of the methods
    with fit and predict of some wariants of regression models

    print some results of each regression models
    draw plot of pairwise relationship in a whole dataset.

    Args:
        first 4 args is result of execution of train_test_split function

        fr1: feature train data set
        fe1: feature test data set
        tr1: target train data set
        te1: target test data set

        name: name of column for wich we build our regression (selling price/original price)

    Returns:
        Nothing, just prints results on console and draw some plots
  """
  fit_and_predict_LinearRegression(fr1, fe1, tr1, te1, name)
  fit_and_predict_GradientBoostingRegressor(fr1, fe1, tr1, te1, name)
  fit_and_predict_ElasticNet(fr1, fe1, tr1, te1, name)
  fit_and_predict_SGDRegressor(fr1, fe1, tr1, te1, name)
  fit_and_predict_SVR(fr1, fe1, tr1, te1, name)
  fit_and_predict_BayesianRidge(fr1, fe1, tr1, te1, name)
  fit_and_predict_KernelRidge(fr1, fe1, tr1, te1, name)
  fit_and_predict_XGBRegressor(fr1, fe1, tr1, te1, name)
  fit_and_predict_LGBMRegressor(fr1, fe1, tr1, te1, name)


  #seaborn draw a plot of pairwise relationship in whole dataset
  #train_dataset = fr1.copy()
  #train_dataset.insert(0, "PRICE", tr1)
  #_ = sns.pairplot(train_dataset, kind="reg", diag_kind="kde")

def fit_and_predict_LGBMRegressor(fr1, fe1, tr1, te1, name):
  """
    This method use LGBM Regressor model for fit and predict

    print some results of fitted model

    Args:
        first 4 args is result of execution of train_test_split function

        fr1: feature train data set
        fe1: feature test data set
        tr1: target train data set
        te1: target test data set

        name: name of column for wich we build our regression (selling price/original price)

    Returns:
        Nothing, just prints results on console
  """
  m_lgbmr = LGBMRegressor()
  m_lgbmr.fit(fr1, tr1)
  res = m_lgbmr.predict(fe1)
  print(f"{name} LGBMRegressor Mean squared error: %.2f" % mean_squared_error(te1, res))
  print(f"{name} LGBMRegressor coeff of determination: %.2f" % r2_score(te1, res))

def fit_and_predict_XGBRegressor(fr1, fe1, tr1, te1, name):
  """
    This method use XGBoost Regressor model for fit and predict

    print some results of fitted model

    Args:
        first 4 args is result of execution of train_test_split function

        fr1: feature train data set
        fe1: feature test data set
        tr1: target train data set
        te1: target test data set

        name: name of column for wich we build our regression (selling price/original price)

    Returns:
        Nothing, just prints results on console
  """
  m_xgbr = XGBRegressor()
  m_xgbr.fit(fr1, tr1)
  res = m_xgbr.predict(fe1)
  print(f"{name} XGBRegressor Mean squared error: %.2f" % mean_squared_error(te1, res))
  print(f"{name} XGBRegressor coeff of determination: %.2f" % r2_score(te1, res))

def fit_and_predict_KernelRidge(fr1, fe1, tr1, te1, name):
  """
    This method use Kernel Ridge Regression model for fit and predict

    print some results of fitted model

    Args:
        first 4 args is result of execution of train_test_split function

        fr1: feature train data set
        fe1: feature test data set
        tr1: target train data set
        te1: target test data set

        name: name of column for wich we build our regression (selling price/original price)

    Returns:
        Nothing, just prints results on console
  """
  m_kr = KernelRidge()
  m_kr.fit(fr1, tr1)
  res = m_kr.predict(fe1)
  print(f"{name} KernelRidge Mean squared error: %.2f" % mean_squared_error(te1, res))
  print(f"{name} KernelRidge coeff of determination: %.2f" % r2_score(te1, res))


def fit_and_predict_BayesianRidge(fr1, fe1, tr1, te1, name):
  """
    This method use Bayesian Ridge Regression model for fit and predict

    print some results of fitted model

    Args:
        first 4 args is result of execution of train_test_split function

        fr1: feature train data set
        fe1: feature test data set
        tr1: target train data set
        te1: target test data set

        name: name of column for wich we build our regression (selling price/original price)

    Returns:
        Nothing, just prints results on console
  """
  m_br = BayesianRidge()
  m_br.fit(fr1, tr1)
  res = m_br.predict(fe1)
  print(f"{name} BayesianRidge Mean squared error: %.2f" % mean_squared_error(te1, res))
  print(f"{name} BayesianRidge coeff of determination: %.2f" % r2_score(te1, res))

def fit_and_predict_SVR(fr1, fe1, tr1, te1, name):
  """
    This method use Support Vector Machine model for fit and predict

    print some results of fitted model

    Args:
        first 4 args is result of execution of train_test_split function

        fr1: feature train data set
        fe1: feature test data set
        tr1: target train data set
        te1: target test data set

        name: name of column for wich we build our regression (selling price/original price)

    Returns:
        Nothing, just prints results on console
  """
  m_svr = SVR()
  m_svr.fit(fr1, tr1)
  res = m_svr.predict(fe1)
  print(f"{name} SVR Mean squared error: %.2f" % mean_squared_error(te1, res))
  print(f"{name} SVR coeff of determination: %.2f" % r2_score(te1, res))

def fit_and_predict_SGDRegressor(fr1, fe1, tr1, te1, name):
  """
    This method use Stochastic Gradient Descent Regression model for fit and predict

    print some results of fitted model

    Args:
        first 4 args is result of execution of train_test_split function

        fr1: feature train data set
        fe1: feature test data set
        tr1: target train data set
        te1: target test data set

        name: name of column for wich we build our regression (selling price/original price)

    Returns:
        Nothing, just prints results on console
  """
  m_sgdr = SGDRegressor()
  m_sgdr.fit(fr1, tr1)
  res = m_sgdr.predict(fe1)
  print(f"{name} SGDRegressor Mean squared error: %.2f" % mean_squared_error(te1, res))
  print(f"{name} SGDRegressor coeff of determination: %.2f" % r2_score(te1, res))

def fit_and_predict_ElasticNet(fr1, fe1, tr1, te1, name):
  """
    This method use Elastic Net Regression model for fit and predict

    print some results of fitted model

    Args:
        first 4 args is result of execution of train_test_split function

        fr1: feature train data set
        fe1: feature test data set
        tr1: target train data set
        te1: target test data set

        name: name of column for wich we build our regression (selling price/original price)

    Returns:
        Nothing, just prints results on console
  """
  m_en = ElasticNet()
  m_en.fit(fr1, tr1)
  res = m_en.predict(fe1)
  print(f"{name} ElasticNet Mean squared error: %.2f" % mean_squared_error(te1, res))
  print(f"{name} ElasticNet coeff of determination: %.2f" % r2_score(te1, res))

def fit_and_predict_GradientBoostingRegressor(fr1, fe1, tr1, te1, name):
  """
    This method use Gradient Boosting Regression model for fit and predict

    print some results of fitted model

    Args:
        first 4 args is result of execution of train_test_split function

        fr1: feature train data set
        fe1: feature test data set
        tr1: target train data set
        te1: target test data set

        name: name of column for wich we build our regression (selling price/original price)

    Returns:
        Nothing, just prints results on console
  """
  m_gbr = GradientBoostingRegressor()
  m_gbr.fit(fr1, tr1)
  res = m_gbr.predict(fe1)
  print(f"{name} GradientBoostingRegressor Mean squared error: %.2f" % mean_squared_error(te1, res))
  print(f"{name} GradientBoostingRegressor coeff of determination: %.2f" % r2_score(te1, res))

def fit_and_predict_LinearRegression(fr1, fe1, tr1, te1, name):
  """
    This method use Linear Regression model for fit and predict

    print some results of fitted model

    Args:
        first 4 args is result of execution of train_test_split function

        fr1: feature train data set
        fe1: feature test data set
        tr1: target train data set
        te1: target test data set

        name: name of column for wich we build our regression (selling price/original price)

    Returns:
        Nothing, just prints results on console
  """
  m = LinearRegression() # create model for linear regression
  m.fit(fr1, tr1) # fit model
  result = m.predict(fe1) # predict
  # print some results of linear regression below
  print(f"{name} linear regression coeffs: \n", m.coef_)
  print(f"{name} LinearRegression Mean squared error: %.2f" % mean_squared_error(te1, result))
  print(f"{name} LinearRegression coeff of determination: %.2f" % r2_score(te1, result))

def main():

  dataset = pd.read_excel('datasetpython.xlsx', engine='openpyxl')
  dataset = dataset.dropna()
  mobile = list(dataset["Mobile"])

  company = list(resolve_company_names(mobile))

  price = list(count_average_price(company, dataset))

  draw_prices(dataset)
  draw_average_prices(company, price)

  #print("Regression models on base dataset without any modification")
  origPrice = split_data(dataset.drop("Selling price", axis=1), "Original price")
  sellingPrice = split_data(dataset.drop("Original price", axis=1), "Selling price")

  #original price
  fit_and_predict_all(origPrice[0], origPrice[1], origPrice[2], origPrice[3], "Original price")
  #selling price
  fit_and_predict_all(sellingPrice[0], sellingPrice[1], sellingPrice[2], sellingPrice[3], "Selling price")

  print("Regression models on modified dataset")
  cols = [5,6,8,10,12,13,15,17,18,19,20,21,22]
  datasetModified = dataset.drop(dataset.columns[cols], axis=1)

  origPriceM = split_data(datasetModified.drop("Selling price", axis=1), "Original price")
  sellingPriceM = split_data(datasetModified.drop("Original price", axis=1), "Selling price")

  #original price
  fit_and_predict_all(origPrice[0], origPrice[1], origPrice[2], origPrice[3], "Original price")
  #selling price
  fit_and_predict_all(sellingPrice[0], sellingPrice[1], sellingPrice[2], sellingPrice[3], "Selling price")


main()